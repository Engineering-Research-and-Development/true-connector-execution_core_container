# Use with Spring Profile SENDER "java -Dspring.profiles.active=SENDER"
spring.banner.location=classpath:true-connector-banner.txt

logging.config=classpath:logback-SENDER.xml

# Choose which events to log from list bellow
#auditableEvents=ALL,NONE,SELF_DESCRIPTION,SELF_DESCRIPTION_ALL,CONTRACT_OFFER,OFFERED_RESOURCE,REPRESENTATION,USER,EXCEPTION,CONNECTOR
# if left empty it will default to ALL
application.logging.auditableEvents=

#GLOBAL PROPERTIES
#define the directory where you can find certificates
application.targetDirectory=C:\\PROJECTS\\IDS\\certificates\\
#SSL Settings for https communication (Related to Springboot)
#use https instead of http, if false the ssl settings can be empty
#Selfdescription SSL Settings
server.ssl.enabled=true
application.ssl.key-store.name=ssl-server.jks
application.ssl.key-store-password=changeit
application.ssl.key-password=changeit

# Check the configurations !!!
### App setup
server.port=8445
server.max-http-header-size=15360
server.ssl.key-alias=execution-core-container
server.ssl.key-password=${application.ssl.key-password}
server.ssl.key-store-password=${application.ssl.key-store-password}
server.ssl.key-store=${application.targetDirectory}${application.ssl.key-store.name}
server.ssl.key-store-provider=SUN
server.ssl.key-store-type=JKS
server.ssl.SHA256=AC3BCAED1F01C63E18D4E0994C48D18EB6F79D01844564A4BA8476BE2D17F5E4
#disable hostname validation
application.disableSslVerification=true

#enable protocol validation (default=false)
#if false the Forward-To header is same as input
application.enableProtocolValidation=false
#true = checks if the protocol in Forward-To is correct (https/http://example.com || wss://example.com || idscp://example.com) based on selected configuration
#false = if the protocol in Forward-To is not correct it will overwrite it based on selected configuration
#application.websocket.isEnabled(wss) and camel.component.jetty.use-global-ssl-context-parameters(http/https) these properties influence the behavior
application.validateProtocol=true

application.encodeDecodePayload=false

### DAPS Parameters (for getting token)
application.isEnabledDapsInteraction=true
#Cache token(true) or always use new token(false)
application.tokenCaching=true
#Fetch and cache token on startup. application.tokenCaching must be true!
application.fetchTokenOnStartup=true
#v1,v2,orbiter
application.dapsVersion=v2
#Orbiter
application.daps.orbiter.privateKey=IDS-Connector.key
application.daps.orbiter.password=IDS-Connector.pem
#application.daps.orbiter.privateKey=privatekeyeng.key IC
#application.daps.orbiter.password=publickeyeng.pem IC
#AISEC v2 URL
application.dapsUrl=https://daps.aisec.fraunhofer.de/v2/token
application.dapsJWKSUrl=https://daps.aisec.fraunhofer.de/.well-known/jwks.json
#Orbiter
#application.dapsUrl= http://212.81.222.225:8084/token
application.keyStoreName=eng-ecc-consumer.p12
application.keyStorePassword=password
application.keystoreAliasName=1
#application.connectorUUID=4c49777d-4718-4d5c-9afe-1057849c1256
#V2
#application.keyStoreName=testbed1.p12
application.connectorUUID=c33cdc09-1745-4371-a0f9-822b305da7e2
#application.connectorUUID=6a963d6c-d82e-4691-99b0-6cd57b598925
#DAPS URI for validating
#application.dapsUrl=https://omejdn/auth/token
#application.dapsJWKSUrl=https://omejdn/auth/jwks.json
application.trustStoreName=truststore.p12
application.trustStorePassword=changeit


### Clearng-House
application.clearinghouse.isEnabledClearingHouse=false
application.clearinghouse.username=
application.clearinghouse.password=
#Clearing House endpoint and local dir for hashing
application.clearinghouse.baseUrl=https://localhost:9999
application.clearinghouse.logEndpoint=/messages/log/
application.clearinghouse.processEndpoint=/process/

#D endpoint

#Connector URIs
application.uriSchema=http
application.uriAuthority=//w3id.org/engrd
#application.uriPath=/autogen/artifactResponseMessage/
application.uriConnector=/connector/consumer

#IDSCP2
application.idscp2.isEnabled=false
#define if the connector is used as receiver
application.isReceiver=false

#HTTP port
http.port=8085

#WSS Port
application.wss.server.port=8087

#Camel A endpoint
application.camelSenderPort=8887

#Camel B endpoint
application.camelReceiverPort=8889

#Open API Data APP
application.openDataAppReceiver=https://localhost:8083/data
#application.openDataAppReceiver=https://localhost:8083/incoming-data-app/routerBodyFormData
#application.openDataAppReceiver=https://localhost:8083/incoming-data-app/routerHttpHeader

# Body: binary
#application.openDataAppReceiverRouter=mixed
# Body: form-data
application.openDataAppReceiverRouter=form
# Body: http-header
#application.openDataAppReceiverRouter=http-header

# Body:binary
#application.eccHttpSendRouter=mixed
# Body: form-data
application.eccHttpSendRouter=form
# Body: http-header
#application.eccHttpSendRouter=http-header

## Health check properties
application.healthcheck.enabled=false
application.healthcheck.cron.expression=0 */5 * ? * *
# fixedDelay in ms
application.healthcheck.resourcemanager.cron.fixedDelay=1000000

## Threshold in percentages - from max value
application.healthcheck.threshold.audit=5
application.healthcheck.threshold.cpu=0.5
application.healthcheck.threshold.memory=10.5

application.healthcheck.dataapp=https://localhost:8083/about/version
application.healthcheck.usagecontrol=https://localhost:8080/platoontec/PlatoonDataUsage/1.0/about/version

application.healthcheck.daps=${application.dapsJWKSUrl}
application.healthcheck.clearinghouse=

#Camel - Spring Boot
camel.springboot.main-run-controller=true
camel.ssl.config.key-managers.key-password=${application.ssl.key-password}
camel.ssl.config.key-managers.key-store.resource=${application.targetDirectory}${application.ssl.key-store.name}
camel.ssl.config.key-managers.key-store.password=${application.ssl.key-store-password}

# scan in the com/foo/routes classpath
camel.xml-routes.directory=classpath:routes

#Camel - HTTP4
#Selfdescription SSL Settings
camel.component.http4.use-global-ssl-context-parameters=true

#Camel - Jetty
#Camel routes SSL Settings
camel.component.jetty.use-global-ssl-context-parameters=true
camel.component.jetty.keystore=${application.targetDirectory}${application.ssl.key-store.name}
camel.component.jetty.ssl-password=${application.ssl.key-store-password}
camel.component.jetty.ssl-key-password=${application.ssl.key-password}

# Enable WebSocket over Https -> Disable Idscp to use!
application.websocket.isEnabled=false
#Enable WS communication channel from/to DataAPP
application.dataApp.websocket.isEnabled=false

# Usage Control App
# platoon or mydata
application.isEnabledUsageControl=false
application.usageControlVersion=platoon
#platoon URL
spring.ids.ucapp.baseUrl=https://localhost:8085/platoontec/PlatoonDataUsage/1.0/
#mydata URL
#spring.ids.ucapp.baseUrl=http://localhost:9552/

#Technical headers
application.technicalHeaders=header,Is-Enabled-DataApp-WebSocket,payload,Forward-To,Payload-Content-Type

#SelfDescription
#API management credentials
application.user.api.username=admin
# 'password' encoded value
application.user.api.password=$2a$10$MQ5grDaIqDpBjMlG78PFduv.AMRe9cs0CNm/V4cgUubrqdGTFCH3m
application.user.connector.username=connector
application.user.connector.password=$2a$10$MQ5grDaIqDpBjMlG78PFduv.AMRe9cs0CNm/V4cgUubrqdGTFCH3m
#number of consecutive failed attempts
application.user.lock.maxattempts=5
# duration for how long user will be locked
application.user.lock.duration=30
# time unit used for locking user, possible values are: SECONDS,MINUTES,HOURS,DAYS
application.user.lock.unit=MINUTES

application.selfdescription.description=Sender Connector description
application.selfdescription.title=Sender Connector title
application.selfdescription.curator=http://sender.curatorURI.com
application.selfdescription.maintainer=http://sender.maintainerURI.com
application.selfdescription.registrateOnStartup=false
application.selfdescription.brokerURL=https://broker.ids.isst.fraunhofer.de/infrastructure
application.selfdescription.filelocation=C:\\Users\\david.jovanovic\\Documents\\work11.20\\market4.0-execution_core_container_business_logic\\src\\main\\resources

##Password Validator
#Password length should be in between (for example) 8 and 16 characters, minLength = 0 to disable the rule, maxLength mandatory
application.password.validator.min-length=8
application.password.validator.maxLength=16
#minimum number of Upper-case characters allowed, 0 to disable the rule
application.password.validator.min-upper-case=1
#minimum number of Lower-case characters allowed, 0 to disable the rule
application.password.validator.min-lower-case=1
#minimum number of digit allowed, 0 to disable the rule
application.password.validator.min-digit=1
#minimum number of special characters allowed, 0 to disable the rule
application.password.validator.min-special=1

#Springdoc
springdoc.packagesToScan=it.eng.idsa.businesslogic.web.rest
springdoc.pathsToMatch=/**
springdoc.writer-with-default-pretty-printer=true

#For logging the response over WSS set to DEBUG, else leave empty
#logging.level.it.eng.idsa.businesslogic.processor.sender.websocket.client=
